O-Notation und Rekurrenzen

Algorithmus: endlich, präzise beschrieben, Eingabe -> Ausgabe, deterministisch, Schritte sind elementar/atomar (ausführbar),
Termination

O-Notation = Landau Notation

O(g(n)) = { f | 

	''' Obere Schranke '''
	1. es existiert min. ein c € R+
	2. es existiert min. ein n0 € N
	3. für alle n >= n0 gilt f(n) <= c * g(n)

}

f(n) € O(g(n)) <=> lim_n -> inf f(n)/g(n) < inf
wenn limes gegen unendlich läuft werden Variablen wie
3/n oder n/3 unendlich klein/groß und können herausfaktorisiert 
werden.

Omega(g(n)) = { f |
	
	''' Untere Schranke '''
	1. es existiert min. ein c € R+
	2. es existiert min. ein n0 € N
	3. für alle n >= n0 gilt f(n) >= c * g(n)	

}

Theta(g(n)) = { f |
	
	''' Untere und obere Schranke '''
	1. es existiert min. ein c1, c2 € R+
	2. es existiert min. ein n0 € N
	3. für alle n >= n0 gilt c1 * g(n) <= f(n) <= c2*g(n)	

}

Merkhilfe: 
. f asymptotisch kleiner gleich, größer gleich.. als g
f € O(g) ~ f <= g
f € Omega(g) ~ f >= g
f € Theta(g) ~ f = g
f € o(g) ~ f < g
f € w(g) ~ f > g

1. f € X(g) und g € X(h) impliziert f € X(h) (X € {O, Omega, Theta, o, w})
2. f € X(f) (X € {O, Omega, Theta})
3. f € Theta(g) <=> g € Theta(f)


Logarithmen:
	b^y = x <=> log_b(x) = y
	bsp: 2^3 = 8 so log_2(8) = 3

	1. log_b(1) = 0 
	2. log_b(b) = 1
	3. log_b(x * y) = log_b(x) + log_b(y)
	4. log_b(x / y) = log_b(x) - log_b(y)
	5. log_b(x ^ r) = r * log_b(x)

Wurzelfunktionen:
	SR = square_root_n
	b^n = a <=> SR(a) = b <=> a ^ 1/n
	SR(a ^ s) = a ^ s/n

	1. SR(a) * SR(b) = SR(a * b)
	2. SR(a) / SR(b) = SR(a / b)
	3. a ^ m/n = SR(a ^ m) = (SR(a)) ^ m
	4. a ^ -(m/n) = a ^ (1/(m/n))
	5. square_root_m(SR(a)) = SR(square_root_m(a)) = square_root_m*n(a)
	6. SR(a) * square_root_m(a) = square_root_n*m(a ^ m+n)

Polynominal:
	
	monomials = x , 1 , 3x^5*y^12
	binomials = x + 3, 2x + g^2
	trinomials = x + 5x + 1

	. degree einer individuellen Variablen ist die Summe der exponenten
	dieser Variable
	. der Grad eines Polynoms ist der größte Grad => max(sum_of_exponent(var), Polynom)
	





